#' @title Prime power MOLS from finite fields
#' 
#' @description
#' Constructs sets of mutually orthogonal Latin squares (MOLS) of dimension p**q where p is 
#' prime. The number of squares r can be any number less than p**q and the exponent q can
#' be any value from 1 up to a maximum dependent on the choice of p. The permitted values of p and q are:
#' 
#'   \tabular{rrrrrrrr}{
#'    \bold{prime p} \tab                                       \bold{maximum q}\cr
#'    2 \tab                                                                12\cr
#'    3 \tab                                                                 7\cr
#'    5 \tab                                                                 5\cr                                                      
#'    7 \tab                                                                 4\cr
#'    11 13 17 19 \tab                                                       3\cr
#'    23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97 \tab                2\cr
#'    101 103 107 etc.  \tab                                                 1
#'    }
#'    
#' 
#' @details Generates MOLS by cyclic permuation of a basic Latin square L0 constructed
#' from a vector of ordered elements X of a prime-power finite field of size
#' p**q and a unit vector 1 of length p**q (see Chapter 1 of Raghavarao 1971).
#' 
#' \eqn{L0 = crossprod(X,t(1)) + crosssprod(1,t(X))}
#' 
#' The primitive polynomials for the MOLS generated by this package were
#' extracted from the Table of Primitive Polynomials given in the Supplement to Hansen and Mullen (1992).
#' 
#' The output is a single data frame for a \eqn{p**q x p**q} square classified by rows and columns 
#' with a separate column for the allocation of treatments to each individual square.
#' 
#' @references
#' 
#' Hansen, T. & Mullen, G. L. (1992) Primitive polynomials over finite fields,
#' Mathematics of Computation, 59, 639-643 and Supplement. 
#' 
#' Raghavarao D. (1971) Constructions and Combinatorial Problems in Design of Experiments,
#' Dover Publications, Inc. Section 1.3
#'  
#' @param p is any odd prime greater than one  
#' 
#' @param q is any suitable integer power (see description for available powers)
#' 
#' @param r is any number of squares up to a maximum of p**q - 1
#' 
#' @return
#' 
#' Data frame of factor levels for rows, columns and treatmnent sets
#'  
#' @examples
#' 
#' MOLS(2,3) # Single Latin square of size 8 x 8
#' MOLS(2,3,7) # Seven MOLS of size 8 x 8
#' MOLS(3,2,4) # Four MOLS of size 9 x 9
#' \donttest{MOLS(3,3,4)} # Four MOLS of size 27 x 27
#' \donttest{MOLS(23,2,2)} # Two MOLS of size 529 x 529
#'  
#' @export
  MOLS=function(p,q,r=1) {
  if (!isPrime(p))  stop("The parameter p must be a prime number ")
  if ( r>(p**q-1) ) stop(paste("Number of replicates exceeds the maximum available number of orthogonal squares" ))
  if (q==1 ) {
  mols=sapply(0:r,function(z){ sapply(0:(p-1), function(j){ (rep(0:(p-1))*z +j)%%p}) })
  mols=data.frame(rep(1:p,p),mols+1)
  mols[c(1,2)]=mols[c(2,1)]
  colnames(mols)=c("Row","Col",paste("T", 1:r, sep = ""))
  return(mols)
  }
  
  if (p > 97) stop("Not a valid prime - if q > 1 then p must be a prime less than 100")
    
  ##  available prime powers
  primes=c(2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97) 
  powers=c(12,7,5,4,3,3,3,3,rep(2,17))
  
  ## primitive polynomials for the MOLS from the Table of Primitive Polynomials given in the Supplement to Hansen and Mullen (1992).
  ## Requires a jstor account for free access at:  https://www.jstor.org/stable/2153093?seq=1
  pp2=list(
  c(1,1,1),
  c(1,0,1,1),
  c(1,0,0,1,1),
  c(1,0,0,1,0,1),
  c(1,0,0,0,0,1,1),
  c(1,0,0,0,0,0,1,1),
  c(1,0,0,0,1,1,1,0,1),
  c(1,0,0,0,0,1,0,0,0,1),
  c(1,0,0,0,0,0,0,1,0,0,1),
  c(1,0,0,0,0,0,0,0,0,1,0,1),
  c(1,0,0,0,0,0,1,0,1,0,0,1,1)) 
  pp3=list(
  c(1,1,2),
  c(1,0,2,1),
  c(1,0,0,1,2),
  c(1,0,0,0,2,1),
  c(1,0,0,0,0,1,2),
  c(1,0,0,0,0,2,0,1))
  pp5=list(
  c(1,1,2),
  c(1,0,3,2),
  c(1,0,1,2,2),
  c(1,0,0,0,4,2))
  pp7=list(
  c(1,1,3),
  c(1,0,3,2),
  c(1,0,1,3,5))
  pp11=list(
  c(1,1,7),
  c(1,0,1,4))
  pp13=list(
  c(1,1,2),
  c(1,0,1,6))
  pp17=list(
  c(1,1,3),
  c(1,0,1,3))
  pp19=list(
  c(1,1,2),
  c(1,0,1,4))
  pp23=list(c(1,1,7))
  pp29=list(c(1,1,3))
  pp31=list(c(1,1,12))
  pp37=list(c(1,1,5))
  pp41=list(c(1,1,12))
  pp43=list(c(1,1,3))
  pp47=list(c(1,1,13))
  pp53=list(c(1,1,5))
  pp59=list(c(1,1,2))
  pp61=list(c(1,1,2))
  pp67=list(c(1,1,12))
  pp71=list(c(1,1,11))
  pp73=list(c(1,1,11))
  pp79=list(c(1,1,3))
  pp83=list(c(1,1,2))
  pp89=list(c(1,1,6))
  pp97=list(c(1,1,5))

primpol=list(pp2,pp3,pp5,pp7,pp11,pp13,pp17,pp19,pp23,pp29,pp31,pp37,pp41,pp43,pp47,pp53,pp59,pp61,pp67,pp71,pp73,pp79,pp83,pp89,pp97)
for (i in 1:25)
  primpol[[i]]=lapply(primpol[[i]],rev)

index=which(p==primes)
if ( q>powers[index] ) stop(paste("Not a valid power - q must be not more than ", powers[index ]))

checkff = function(p,q,X) {
  rowMax=q
  C=lapply(X,coef)
  M= do.call(rbind, lapply(C, function(x){ 
    length(x) <- rowMax 
    x 
  })) 
  if (any(duplicated(data.frame(M))==TRUE)) stop(paste("Could not find a set of primitive elenents for p = ",p," and q = ",q))
}

## functions ued to calculate Galois Fields (gf)

reduce = function(X,primpol,p,q) {
  c=coef(X)
  if(length(c)>q) 
    c=coef(PolynomF::polynomial(c[1:q])+primpol*c[q+1])
  X=PolynomF::polynomial(c%%p)
  X
}

gf = function(p,q,index) {
  primpol=primpol[[index]][[q-1]]
  primpol=PolynomF::polynomial(  (-primpol[1:q])%%p  )
  X = vector(mode = "list", length = p**q)
  X[[1]]=PolynomF::polynomial(c(0,0))
  X[[2]]=PolynomF::polynomial(c(1,0)) 
  X[[3]]=PolynomF::polynomial(c(0,1))
  for( i in 4:p**q) { 
    X[[i]]=X[[i-1]]*X[[3]]
    X[[i]]=reduce(X[[i]],primpol,p,q)
  }
  checkff(p,q,X)
  X
}

modcoef=function(z) {
  coef=lapply(z,  function(x) coef(x)%%p)
  rowMax= max(sapply(coef, length))
  M= do.call(rbind, lapply(coef,function(x){ 
    length(x) = rowMax
    x 
  }))  
  M[is.na(M)] = 0
  M
}

## orthogonal Latin squares by method of Raghavarao
ls=function(p,q,r,index) {
  v=p**q
  shift=c(1:v , (1+2*v):(v*v) , (1+v):(2*v) )
  gf=gf(p,q,index)
  M=modcoef(gf)
  LS=rep(0,v*v)
  for (i in 1:ncol(M))
    LS= LS +   (rep(M[,i],v) + rep(M[,i],each=v))%%p * p**(i-1)
  D=data.frame(LS+1)
  if (r>1) {
    for (i in 2:r) {
      LS=LS[shift]
      D=cbind(D,LS+1)
    }
  }
  D
}

lscheck=function(D,p,q,r) {
  for (i in 1:(r+1)) 
    for (j in (i+1):(r+2)) 
      if (max(table(D[,c(i,j)]))!=1 | min(table(D[,c(i,j)]))!=1) stop(paste("Latin squares for p = ",p," and q= ",q," and r= ",r," are non-orthogonal 
      for i = ",i," and j = ",j," please notify maintainer: rodney.edmondson@gmail.com"))
}

D=ls(p,q,r,index)
colnames(D)=paste("T", 1:ncol(D), sep = "")
Row=rep(1:p**q,each=p**q)
Col=rep(1:p**q,p**q)
D=data.frame(cbind(Row,Col,D))
lscheck(D,p,q,r)

return(D)
}
